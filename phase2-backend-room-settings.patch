diff --git a/package-lock.json b/package-lock.json
index 65648cb..a9e7277 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -9,6 +9,7 @@
       "version": "1.0.0",
       "license": "ISC",
       "dependencies": {
+        "bcrypt": "^6.0.0",
         "compression": "^1.7.4",
         "cors": "^2.8.5",
         "dotenv": "^16.0.3",
@@ -393,6 +394,20 @@
         "node": "^4.5.0 || >= 5.9"
       }
     },
+    "node_modules/bcrypt": {
+      "version": "6.0.0",
+      "resolved": "https://registry.npmjs.org/bcrypt/-/bcrypt-6.0.0.tgz",
+      "integrity": "sha512-cU8v/EGSrnH+HnxV2z0J7/blxH8gq7Xh2JFT6Aroax7UohdmiJJlxApMxtKfuI7z68NvvVcmR78k2LbT6efhRg==",
+      "hasInstallScript": true,
+      "license": "MIT",
+      "dependencies": {
+        "node-addon-api": "^8.3.0",
+        "node-gyp-build": "^4.8.4"
+      },
+      "engines": {
+        "node": ">= 18"
+      }
+    },
     "node_modules/binary-extensions": {
       "version": "2.3.0",
       "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.3.0.tgz",
@@ -1894,6 +1909,26 @@
         "node": ">= 0.6"
       }
     },
+    "node_modules/node-addon-api": {
+      "version": "8.5.0",
+      "resolved": "https://registry.npmjs.org/node-addon-api/-/node-addon-api-8.5.0.tgz",
+      "integrity": "sha512-/bRZty2mXUIFY/xU5HLvveNHlswNJej+RnxBjOMkidWfwZzgTbPG1E3K5TOxRLOR+5hX7bSofy8yf1hZevMS8A==",
+      "license": "MIT",
+      "engines": {
+        "node": "^18 || ^20 || >= 21"
+      }
+    },
+    "node_modules/node-gyp-build": {
+      "version": "4.8.4",
+      "resolved": "https://registry.npmjs.org/node-gyp-build/-/node-gyp-build-4.8.4.tgz",
+      "integrity": "sha512-LA4ZjwlnUblHVgq0oBF3Jl/6h/Nvs5fzBLwdEF4nuxnFdsfajde4WfxtJr3CaiH+F6ewcIB/q4jQ4UzPyid+CQ==",
+      "license": "MIT",
+      "bin": {
+        "node-gyp-build": "bin.js",
+        "node-gyp-build-optional": "optional.js",
+        "node-gyp-build-test": "build-test.js"
+      }
+    },
     "node_modules/nodemon": {
       "version": "3.1.10",
       "resolved": "https://registry.npmjs.org/nodemon/-/nodemon-3.1.10.tgz",
diff --git a/package.json b/package.json
index 746d22f..e459985 100644
--- a/package.json
+++ b/package.json
@@ -7,6 +7,7 @@
     "start": "node server.js",
     "dev": "nodemon server.js",
     "migrate": "node src/database/migrate.js",
+    "migrate:room-settings": "node src/database/add-room-settings.js",
     "seed": "node src/database/seed.js",
     "lint": "eslint .",
     "test": "echo \"Error: no test specified\" && exit 1"
@@ -21,19 +22,20 @@
   "author": "",
   "license": "ISC",
   "dependencies": {
+    "bcrypt": "^6.0.0",
+    "compression": "^1.7.4",
+    "cors": "^2.8.5",
+    "dotenv": "^16.0.3",
     "express": "^5.1.0",
+    "helmet": "^7.0.0",
     "pg": "^8.11.0",
     "sequelize": "^6.35.0",
     "socket.io": "^4.6.0",
-    "cors": "^2.8.5",
-    "dotenv": "^16.0.3",
-    "helmet": "^7.0.0",
-    "compression": "^1.7.4",
     "uuid": "^9.0.0"
   },
   "devDependencies": {
-    "nodemon": "^3.0.1",
-    "eslint": "^8.50.0"
+    "eslint": "^8.50.0",
+    "nodemon": "^3.0.1"
   },
   "engines": {
     "node": ">=18.0.0"
diff --git a/src/database/add-room-settings.js b/src/database/add-room-settings.js
new file mode 100644
index 0000000..105e1f8
--- /dev/null
+++ b/src/database/add-room-settings.js
@@ -0,0 +1,121 @@
+const { sequelize, testConnection } = require('./config');
+const { QueryTypes } = require('sequelize');
+
+async function migrateRoomSettings() {
+  try {
+    console.log('ðŸ”„ Adding room settings columns...');
+
+    await testConnection();
+
+    // Check if columns already exist
+    const columnsQuery = `
+      SELECT column_name
+      FROM information_schema.columns
+      WHERE table_name = 'rooms' AND table_schema = 'public'
+    `;
+
+    const existingColumns = await sequelize.query(columnsQuery, {
+      type: QueryTypes.SELECT
+    });
+
+    const columnNames = existingColumns.map(c => c.column_name);
+
+    // Add password column if not exists
+    if (!columnNames.includes('password')) {
+      await sequelize.query(`
+        ALTER TABLE rooms
+        ADD COLUMN password VARCHAR(255);
+      `);
+      console.log('âœ… Added password column');
+    } else {
+      console.log('â­ï¸  password column already exists');
+    }
+
+    // Add is_private column if not exists
+    if (!columnNames.includes('is_private')) {
+      await sequelize.query(`
+        ALTER TABLE rooms
+        ADD COLUMN is_private BOOLEAN DEFAULT false;
+      `);
+      console.log('âœ… Added is_private column');
+    } else {
+      console.log('â­ï¸  is_private column already exists');
+    }
+
+    // Add owner_user_id column if not exists
+    if (!columnNames.includes('owner_user_id')) {
+      await sequelize.query(`
+        ALTER TABLE rooms
+        ADD COLUMN owner_user_id VARCHAR(255);
+      `);
+      console.log('âœ… Added owner_user_id column');
+    } else {
+      console.log('â­ï¸  owner_user_id column already exists');
+    }
+
+    // Create banned_users table if not exists
+    await sequelize.query(`
+      CREATE TABLE IF NOT EXISTS banned_users (
+        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
+        room_id UUID NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
+        user_identifier VARCHAR(255) NOT NULL,
+        banned_by VARCHAR(255) NOT NULL,
+        reason TEXT,
+        banned_at TIMESTAMP DEFAULT NOW(),
+        expires_at TIMESTAMP,
+        UNIQUE(room_id, user_identifier)
+      );
+    `);
+    console.log('âœ… Created/verified banned_users table');
+
+    // Create room_moderators table if not exists
+    await sequelize.query(`
+      CREATE TABLE IF NOT EXISTS room_moderators (
+        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
+        room_id UUID NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
+        user_identifier VARCHAR(255) NOT NULL,
+        granted_by VARCHAR(255) NOT NULL,
+        permissions JSONB DEFAULT '{"can_kick": true, "can_ban": true, "can_mute": false, "can_change_settings": false}'::jsonb,
+        granted_at TIMESTAMP DEFAULT NOW(),
+        UNIQUE(room_id, user_identifier)
+      );
+    `);
+    console.log('âœ… Created/verified room_moderators table');
+
+    // Create indexes
+    await sequelize.query(`
+      CREATE INDEX IF NOT EXISTS idx_rooms_private_active
+      ON rooms(is_private, is_active);
+    `);
+
+    await sequelize.query(`
+      CREATE INDEX IF NOT EXISTS idx_rooms_owner
+      ON rooms(owner_user_id);
+    `);
+
+    await sequelize.query(`
+      CREATE INDEX IF NOT EXISTS idx_banned_users_room
+      ON banned_users(room_id);
+    `);
+
+    await sequelize.query(`
+      CREATE INDEX IF NOT EXISTS idx_room_moderators_room
+      ON room_moderators(room_id);
+    `);
+
+    console.log('âœ… Created indexes');
+
+    console.log('\nâœ… Room settings migration completed successfully!');
+    process.exit(0);
+  } catch (error) {
+    console.error('âŒ Migration failed:', error);
+    process.exit(1);
+  }
+}
+
+// Run migration if this file is executed directly
+if (require.main === module) {
+  migrateRoomSettings();
+}
+
+module.exports = migrateRoomSettings;
diff --git a/src/database/migrate.js b/src/database/migrate.js
index 3f23a17..2d8aee3 100644
--- a/src/database/migrate.js
+++ b/src/database/migrate.js
@@ -8,16 +8,18 @@ async function migrate() {
     // Test connection
     await testConnection();
 
-    // Sync all models
-    await sequelize.sync({ alter: true });
+    // Sync all models (alter: false for safety)
+    await sequelize.sync({ alter: false });
 
     console.log('âœ… Database migration completed successfully!');
-    console.log('\nCreated tables:');
-    console.log('  - rooms');
+    console.log('\nCreated/Updated tables:');
+    console.log('  - rooms (âœ¨ added: password, is_private, owner_user_id)');
     console.log('  - users');
     console.log('  - messages');
     console.log('  - ice_candidates');
     console.log('  - sdp_signals');
+    console.log('  - banned_users (ðŸ†• new)');
+    console.log('  - room_moderators (ðŸ†• new)');
 
     process.exit(0);
   } catch (error) {
diff --git a/src/models/BannedUser.js b/src/models/BannedUser.js
new file mode 100644
index 0000000..7d19015
--- /dev/null
+++ b/src/models/BannedUser.js
@@ -0,0 +1,57 @@
+const { DataTypes } = require('sequelize');
+const { sequelize } = require('../database/config');
+
+const BannedUser = sequelize.define('BannedUser', {
+  id: {
+    type: DataTypes.UUID,
+    defaultValue: DataTypes.UUIDV4,
+    primaryKey: true
+  },
+  room_id: {
+    type: DataTypes.UUID,
+    allowNull: false,
+    comment: 'Room UUID reference'
+  },
+  user_identifier: {
+    type: DataTypes.STRING,
+    allowNull: false,
+    comment: 'User ID or session identifier'
+  },
+  banned_by: {
+    type: DataTypes.STRING,
+    allowNull: false,
+    comment: 'User ID who banned this user'
+  },
+  reason: {
+    type: DataTypes.TEXT,
+    allowNull: true,
+    comment: 'Reason for ban'
+  },
+  banned_at: {
+    type: DataTypes.DATE,
+    defaultValue: DataTypes.NOW,
+    comment: 'When the user was banned'
+  },
+  expires_at: {
+    type: DataTypes.DATE,
+    allowNull: true,
+    comment: 'When the ban expires (null = permanent)'
+  }
+}, {
+  tableName: 'banned_users',
+  timestamps: false,
+  indexes: [
+    {
+      unique: true,
+      fields: ['room_id', 'user_identifier']
+    },
+    {
+      fields: ['room_id']
+    },
+    {
+      fields: ['expires_at']
+    }
+  ]
+});
+
+module.exports = BannedUser;
diff --git a/src/models/Room.js b/src/models/Room.js
index f2ade4a..79aed99 100644
--- a/src/models/Room.js
+++ b/src/models/Room.js
@@ -18,9 +18,23 @@ const Room = sequelize.define('Room', {
     allowNull: true,
     comment: 'Optional room name'
   },
+  password: {
+    type: DataTypes.STRING,
+    allowNull: true,
+    comment: 'Password hash for protected rooms'
+  },
+  is_private: {
+    type: DataTypes.BOOLEAN,
+    defaultValue: false,
+    comment: 'Whether the room is private (not shown in lobby)'
+  },
   max_users: {
     type: DataTypes.INTEGER,
     defaultValue: 10,
+    validate: {
+      min: 2,
+      max: 50
+    },
     comment: 'Maximum number of users allowed in room'
   },
   is_active: {
@@ -32,6 +46,11 @@ const Room = sequelize.define('Room', {
     type: DataTypes.STRING,
     allowNull: true,
     comment: 'User ID of room creator'
+  },
+  owner_user_id: {
+    type: DataTypes.STRING,
+    allowNull: true,
+    comment: 'Current owner user ID (can transfer ownership)'
   }
 }, {
   tableName: 'rooms',
@@ -39,6 +58,12 @@ const Room = sequelize.define('Room', {
     {
       unique: true,
       fields: ['room_id']
+    },
+    {
+      fields: ['is_private', 'is_active']
+    },
+    {
+      fields: ['owner_user_id']
     }
   ]
 });
diff --git a/src/models/RoomModerator.js b/src/models/RoomModerator.js
new file mode 100644
index 0000000..b6b70c5
--- /dev/null
+++ b/src/models/RoomModerator.js
@@ -0,0 +1,54 @@
+const { DataTypes } = require('sequelize');
+const { sequelize } = require('../database/config');
+
+const RoomModerator = sequelize.define('RoomModerator', {
+  id: {
+    type: DataTypes.UUID,
+    defaultValue: DataTypes.UUIDV4,
+    primaryKey: true
+  },
+  room_id: {
+    type: DataTypes.UUID,
+    allowNull: false,
+    comment: 'Room UUID reference'
+  },
+  user_identifier: {
+    type: DataTypes.STRING,
+    allowNull: false,
+    comment: 'User ID or session identifier'
+  },
+  granted_by: {
+    type: DataTypes.STRING,
+    allowNull: false,
+    comment: 'User ID who granted moderator privileges'
+  },
+  permissions: {
+    type: DataTypes.JSON,
+    defaultValue: {
+      can_kick: true,
+      can_ban: true,
+      can_mute: false,
+      can_change_settings: false
+    },
+    comment: 'Moderator permissions object'
+  },
+  granted_at: {
+    type: DataTypes.DATE,
+    defaultValue: DataTypes.NOW,
+    comment: 'When moderator privileges were granted'
+  }
+}, {
+  tableName: 'room_moderators',
+  timestamps: false,
+  indexes: [
+    {
+      unique: true,
+      fields: ['room_id', 'user_identifier']
+    },
+    {
+      fields: ['room_id']
+    }
+  ]
+});
+
+module.exports = RoomModerator;
diff --git a/src/models/index.js b/src/models/index.js
index 0a6d92c..db65621 100644
--- a/src/models/index.js
+++ b/src/models/index.js
@@ -4,6 +4,8 @@ const User = require('./User');
 const Message = require('./Message');
 const IceCandidate = require('./IceCandidate');
 const SdpSignal = require('./SdpSignal');
+const BannedUser = require('./BannedUser');
+const RoomModerator = require('./RoomModerator');
 
 // Define relationships
 Room.hasMany(User, { foreignKey: 'room_id', as: 'users', onDelete: 'CASCADE' });
@@ -18,11 +20,19 @@ IceCandidate.belongsTo(Room, { foreignKey: 'room_id' });
 Room.hasMany(SdpSignal, { foreignKey: 'room_id', as: 'sdp_signals', onDelete: 'CASCADE' });
 SdpSignal.belongsTo(Room, { foreignKey: 'room_id' });
 
+Room.hasMany(BannedUser, { foreignKey: 'room_id', as: 'banned_users', onDelete: 'CASCADE' });
+BannedUser.belongsTo(Room, { foreignKey: 'room_id' });
+
+Room.hasMany(RoomModerator, { foreignKey: 'room_id', as: 'moderators', onDelete: 'CASCADE' });
+RoomModerator.belongsTo(Room, { foreignKey: 'room_id' });
+
 module.exports = {
   sequelize,
   Room,
   User,
   Message,
   IceCandidate,
-  SdpSignal
+  SdpSignal,
+  BannedUser,
+  RoomModerator
 };
diff --git a/src/routes/rooms.js b/src/routes/rooms.js
index c9b329b..fa3aa41 100644
--- a/src/routes/rooms.js
+++ b/src/routes/rooms.js
@@ -1,8 +1,10 @@
 const express = require('express');
-const { Room, User, Message } = require('../models');
+const bcrypt = require('bcrypt');
+const { Room, User, Message, BannedUser, RoomModerator } = require('../models');
 const { Op } = require('sequelize');
 
 const router = express.Router();
+const SALT_ROUNDS = 10;
 
 // Get all active rooms
 router.get('/', async (req, res) => {
@@ -23,6 +25,8 @@ router.get('/', async (req, res) => {
       name: room.name,
       userCount: room.users.length,
       maxUsers: room.max_users,
+      isPrivate: room.is_private,
+      hasPassword: !!room.password,
       createdBy: room.created_by,
       createdAt: room.created_at
     }));
@@ -34,6 +38,39 @@ router.get('/', async (req, res) => {
   }
 });
 
+// Get public rooms (for lobby)
+router.get('/lobby/list', async (req, res) => {
+  try {
+    const rooms = await Room.findAll({
+      where: {
+        is_active: true,
+        is_private: false
+      },
+      include: [{
+        model: User,
+        as: 'users',
+        where: { is_connected: true },
+        required: false
+      }],
+      order: [['created_at', 'DESC']]
+    });
+
+    const roomList = rooms.map(room => ({
+      roomId: room.room_id,
+      name: room.name,
+      currentUsers: room.users.length,
+      maxUsers: room.max_users,
+      hasPassword: !!room.password,
+      createdAt: room.created_at
+    }));
+
+    res.json({ rooms: roomList });
+  } catch (error) {
+    console.error('Error fetching lobby rooms:', error);
+    res.status(500).json({ error: 'Failed to fetch lobby rooms' });
+  }
+});
+
 // Get room by ID
 router.get('/:roomId', async (req, res) => {
   try {
@@ -107,7 +144,7 @@ router.get('/:roomId/messages', async (req, res) => {
 // Create a new room (REST endpoint - can also use WebSocket)
 router.post('/', async (req, res) => {
   try {
-    const { roomId, name, maxUsers } = req.body;
+    const { roomId, name, maxUsers, password, isPrivate, createdBy } = req.body;
 
     // Generate room ID if not provided
     const newRoomId = roomId || Math.random().toString(36).substring(2, 8);
@@ -118,17 +155,29 @@ router.post('/', async (req, res) => {
       return res.status(409).json({ error: 'Room ID already exists' });
     }
 
+    // Hash password if provided
+    let passwordHash = null;
+    if (password && password.length > 0) {
+      passwordHash = await bcrypt.hash(password, SALT_ROUNDS);
+    }
+
     const room = await Room.create({
       room_id: newRoomId,
       name: name || null,
+      password: passwordHash,
+      is_private: isPrivate || false,
       max_users: maxUsers || 10,
-      is_active: true
+      is_active: true,
+      created_by: createdBy || null,
+      owner_user_id: createdBy || null
     });
 
     res.status(201).json({
       roomId: room.room_id,
       name: room.name,
       maxUsers: room.max_users,
+      isPrivate: room.is_private,
+      hasPassword: !!room.password,
       createdAt: room.created_at
     });
   } catch (error) {
@@ -168,4 +217,344 @@ router.delete('/:roomId', async (req, res) => {
   }
 });
 
+// Update room settings
+router.put('/:roomId/settings', async (req, res) => {
+  try {
+    const { roomId } = req.params;
+    const { userId, name, maxUsers, password, isPrivate } = req.body;
+
+    const room = await Room.findOne({ where: { room_id: roomId } });
+
+    if (!room) {
+      return res.status(404).json({ error: 'Room not found' });
+    }
+
+    // Check if user is owner
+    if (room.owner_user_id !== userId) {
+      return res.status(403).json({ error: 'Only room owner can change settings' });
+    }
+
+    const updates = {};
+
+    if (name !== undefined) updates.name = name;
+    if (maxUsers !== undefined) updates.max_users = maxUsers;
+    if (isPrivate !== undefined) updates.is_private = isPrivate;
+
+    // Update password if provided
+    if (password !== undefined) {
+      if (password === null || password === '') {
+        updates.password = null;
+      } else {
+        updates.password = await bcrypt.hash(password, SALT_ROUNDS);
+      }
+    }
+
+    await room.update(updates);
+
+    res.json({
+      message: 'Settings updated successfully',
+      room: {
+        roomId: room.room_id,
+        name: room.name,
+        maxUsers: room.max_users,
+        isPrivate: room.is_private,
+        hasPassword: !!room.password
+      }
+    });
+  } catch (error) {
+    console.error('Error updating room settings:', error);
+    res.status(500).json({ error: 'Failed to update room settings' });
+  }
+});
+
+// Verify room password
+router.post('/:roomId/verify-password', async (req, res) => {
+  try {
+    const { roomId } = req.params;
+    const { password } = req.body;
+
+    const room = await Room.findOne({ where: { room_id: roomId } });
+
+    if (!room) {
+      return res.status(404).json({ error: 'Room not found' });
+    }
+
+    if (!room.password) {
+      return res.json({ valid: true });
+    }
+
+    const isValid = await bcrypt.compare(password || '', room.password);
+
+    res.json({ valid: isValid });
+  } catch (error) {
+    console.error('Error verifying password:', error);
+    res.status(500).json({ error: 'Failed to verify password' });
+  }
+});
+
+// Kick user from room
+router.post('/:roomId/kick', async (req, res) => {
+  try {
+    const { roomId } = req.params;
+    const { userId, targetUserId } = req.body;
+
+    const room = await Room.findOne({ where: { room_id: roomId } });
+
+    if (!room) {
+      return res.status(404).json({ error: 'Room not found' });
+    }
+
+    // Check if user is owner or moderator
+    const isOwner = room.owner_user_id === userId;
+    const isModerator = await RoomModerator.findOne({
+      where: {
+        room_id: room.id,
+        user_identifier: userId
+      }
+    });
+
+    if (!isOwner && !isModerator) {
+      return res.status(403).json({ error: 'Only owner or moderators can kick users' });
+    }
+
+    // Disconnect the target user via WebSocket
+    const io = req.app.get('io');
+    const targetUser = await User.findOne({
+      where: {
+        room_id: room.id,
+        user_id: targetUserId,
+        is_connected: true
+      }
+    });
+
+    if (targetUser && targetUser.socket_id) {
+      io.to(targetUser.socket_id).emit('kicked', {
+        roomId,
+        reason: 'Kicked by room owner/moderator'
+      });
+    }
+
+    // Update user status
+    await User.update(
+      { is_connected: false, left_at: new Date() },
+      { where: { room_id: room.id, user_id: targetUserId } }
+    );
+
+    res.json({ message: 'User kicked successfully' });
+  } catch (error) {
+    console.error('Error kicking user:', error);
+    res.status(500).json({ error: 'Failed to kick user' });
+  }
+});
+
+// Ban user from room
+router.post('/:roomId/ban', async (req, res) => {
+  try {
+    const { roomId } = req.params;
+    const { userId, targetUserId, reason, duration } = req.body;
+
+    const room = await Room.findOne({ where: { room_id: roomId } });
+
+    if (!room) {
+      return res.status(404).json({ error: 'Room not found' });
+    }
+
+    // Check if user is owner or moderator
+    const isOwner = room.owner_user_id === userId;
+    const isModerator = await RoomModerator.findOne({
+      where: {
+        room_id: room.id,
+        user_identifier: userId
+      }
+    });
+
+    if (!isOwner && !isModerator) {
+      return res.status(403).json({ error: 'Only owner or moderators can ban users' });
+    }
+
+    // Calculate expiry if duration provided (in hours)
+    let expiresAt = null;
+    if (duration) {
+      expiresAt = new Date(Date.now() + duration * 60 * 60 * 1000);
+    }
+
+    // Create ban record
+    await BannedUser.create({
+      room_id: room.id,
+      user_identifier: targetUserId,
+      banned_by: userId,
+      reason: reason || null,
+      expires_at: expiresAt
+    });
+
+    // Kick the user if currently connected
+    const io = req.app.get('io');
+    const targetUser = await User.findOne({
+      where: {
+        room_id: room.id,
+        user_id: targetUserId,
+        is_connected: true
+      }
+    });
+
+    if (targetUser && targetUser.socket_id) {
+      io.to(targetUser.socket_id).emit('banned', {
+        roomId,
+        reason: reason || 'Banned by room owner/moderator',
+        expiresAt
+      });
+    }
+
+    // Disconnect user
+    await User.update(
+      { is_connected: false, left_at: new Date() },
+      { where: { room_id: room.id, user_id: targetUserId } }
+    );
+
+    res.json({
+      message: 'User banned successfully',
+      expiresAt
+    });
+  } catch (error) {
+    console.error('Error banning user:', error);
+    res.status(500).json({ error: 'Failed to ban user' });
+  }
+});
+
+// Unban user
+router.delete('/:roomId/ban/:targetUserId', async (req, res) => {
+  try {
+    const { roomId, targetUserId } = req.params;
+    const { userId } = req.body;
+
+    const room = await Room.findOne({ where: { room_id: roomId } });
+
+    if (!room) {
+      return res.status(404).json({ error: 'Room not found' });
+    }
+
+    // Check if user is owner or moderator
+    const isOwner = room.owner_user_id === userId;
+    if (!isOwner) {
+      return res.status(403).json({ error: 'Only owner can unban users' });
+    }
+
+    await BannedUser.destroy({
+      where: {
+        room_id: room.id,
+        user_identifier: targetUserId
+      }
+    });
+
+    res.json({ message: 'User unbanned successfully' });
+  } catch (error) {
+    console.error('Error unbanning user:', error);
+    res.status(500).json({ error: 'Failed to unban user' });
+  }
+});
+
+// Get banned users list
+router.get('/:roomId/bans', async (req, res) => {
+  try {
+    const { roomId } = req.params;
+
+    const room = await Room.findOne({ where: { room_id: roomId } });
+
+    if (!room) {
+      return res.status(404).json({ error: 'Room not found' });
+    }
+
+    const bans = await BannedUser.findAll({
+      where: {
+        room_id: room.id,
+        [Op.or]: [
+          { expires_at: null },
+          { expires_at: { [Op.gt]: new Date() } }
+        ]
+      },
+      order: [['banned_at', 'DESC']]
+    });
+
+    res.json({
+      bans: bans.map(ban => ({
+        userId: ban.user_identifier,
+        bannedBy: ban.banned_by,
+        reason: ban.reason,
+        bannedAt: ban.banned_at,
+        expiresAt: ban.expires_at
+      }))
+    });
+  } catch (error) {
+    console.error('Error fetching banned users:', error);
+    res.status(500).json({ error: 'Failed to fetch banned users' });
+  }
+});
+
+// Add moderator
+router.post('/:roomId/moderator', async (req, res) => {
+  try {
+    const { roomId } = req.params;
+    const { userId, targetUserId, permissions } = req.body;
+
+    const room = await Room.findOne({ where: { room_id: roomId } });
+
+    if (!room) {
+      return res.status(404).json({ error: 'Room not found' });
+    }
+
+    // Only owner can add moderators
+    if (room.owner_user_id !== userId) {
+      return res.status(403).json({ error: 'Only owner can add moderators' });
+    }
+
+    await RoomModerator.create({
+      room_id: room.id,
+      user_identifier: targetUserId,
+      granted_by: userId,
+      permissions: permissions || {
+        can_kick: true,
+        can_ban: true,
+        can_mute: false,
+        can_change_settings: false
+      }
+    });
+
+    res.json({ message: 'Moderator added successfully' });
+  } catch (error) {
+    console.error('Error adding moderator:', error);
+    res.status(500).json({ error: 'Failed to add moderator' });
+  }
+});
+
+// Remove moderator
+router.delete('/:roomId/moderator/:targetUserId', async (req, res) => {
+  try {
+    const { roomId, targetUserId } = req.params;
+    const { userId } = req.body;
+
+    const room = await Room.findOne({ where: { room_id: roomId } });
+
+    if (!room) {
+      return res.status(404).json({ error: 'Room not found' });
+    }
+
+    // Only owner can remove moderators
+    if (room.owner_user_id !== userId) {
+      return res.status(403).json({ error: 'Only owner can remove moderators' });
+    }
+
+    await RoomModerator.destroy({
+      where: {
+        room_id: room.id,
+        user_identifier: targetUserId
+      }
+    });
+
+    res.json({ message: 'Moderator removed successfully' });
+  } catch (error) {
+    console.error('Error removing moderator:', error);
+    res.status(500).json({ error: 'Failed to remove moderator' });
+  }
+});
+
 module.exports = router;
